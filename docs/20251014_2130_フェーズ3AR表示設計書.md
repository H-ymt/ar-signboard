# AR 看板アプリ - フェーズ3: AR表示とインタラクション設計書

**作成日**: 2025-10-14
**バージョン**: 1.0.0
**フェーズ**: Phase 3 - AR表示とインタラクション実装
**前提**: フェーズ2（コア機能）が完了している状態
**実装期間**: 1週間（想定）

---

## 1. 設計の目的と概要

### 1.1 目的

フェーズ3では、AR看板アプリケーションの**AR表示とインタラクション機能**を実装します。具体的には以下の機能を提供します：

- A-Frameを使用した3Dシーンの構築
- MindARによる画像認識とトラッキング
- 2D看板画像のAR空間への配置
- タッチジェスチャーによる操作（移動・回転・拡大縮小）
- 複数の看板デザインの切替機能

### 1.2 前提条件

- フェーズ2（コア機能）が完了していること
  - ✅ カメラアクセス機能
  - ✅ MindAR初期化機能
  - ✅ エラーハンドリング
  - ✅ 型定義とユーティリティ

### 1.3 成果物

このフェーズ完了時には以下が動作すること：

- ターゲット画像を認識してAR表示が開始される
- 看板画像がターゲット上に正しく配置される
- ドラッグで看板を移動できる
- ピンチで看板を拡大縮小できる
- 回転ジェスチャーで看板を回転できる
- デザイン切替UIで異なる看板に変更できる

---

## 2. アーキテクチャ設計

### 2.1 コンポーネント構造

```
┌─────────────────────────────────────────┐
│           App Component                 │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐   │
│  │     ARScene Component           │   │
│  │  ┌───────────────────────────┐  │   │
│  │  │  A-Frame Scene            │  │   │
│  │  │  - Camera                 │  │   │
│  │  │  - Entity (Target)        │  │   │
│  │  │    - Plane (Signboard)    │  │   │
│  │  └───────────────────────────┘  │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │   ControlsOverlay Component     │   │
│  │   - Help Text                   │   │
│  │   - Design Switcher             │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### 2.2 データフロー

```
[Camera Stream] → [MindAR Recognition]
                        ↓
                [Target Found Event]
                        ↓
              [Update Tracking State]
                        ↓
            [Render AR Entity with Transform]
                        ↓
              [Touch Gesture Input]
                        ↓
           [Calculate New Transform]
                        ↓
            [Update Entity Position/Rotation/Scale]
```

---

## 3. 詳細設計

### 3.1 ターゲット画像の準備

#### 3.1.1 ターゲット画像の要件

- **画像形式**: JPEG, PNG
- **推奨サイズ**: 1024x1024px 以下
- **特徴点**: コントラストが高く、特徴的なパターンを持つこと
- **変換形式**: .mind形式（MindARコンパイラで生成）

#### 3.1.2 ターゲット画像のコンパイル

```bash
# MindAR Image Target Compilerのインストール
npm install -g mind-ar-cli

# ターゲット画像のコンパイル
mind-ar-cli compile \
  --input public/targets/sample-target.jpg \
  --output public/targets/sample-target.mind \
  --max-track 1
```

#### 3.1.3 サンプルターゲット画像

デフォルトでは、以下のサンプル画像を使用：

- `public/targets/default-target.jpg` - オリジナルのターゲット画像
- `public/targets/default-target.mind` - コンパイル済みターゲットファイル

---

### 3.2 ARシーンコンポーネントの実装

#### 3.2.1 ARScene コンポーネント（`src/components/ar/ARScene.tsx`）

```typescript
import { useEffect, useRef } from 'react';
import 'aframe';
import 'mind-ar/dist/mindar-image-aframe.prod.js';

import type { SignboardDesign } from '../../types/signboard';
import type { Transform } from '../../types/ar';

interface ARSceneProps {
  targetUrl: string;
  signboard: SignboardDesign;
  transform: Transform;
  onTargetFound: () => void;
  onTargetLost: () => void;
  onTransformChange: (transform: Transform) => void;
}

export const ARScene = ({
  targetUrl,
  signboard,
  transform,
  onTargetFound,
  onTargetLost,
  onTransformChange,
}: ARSceneProps) => {
  const sceneRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!sceneRef.current) return;

    const sceneEl = sceneRef.current.querySelector('a-scene');
    if (!sceneEl) return;

    // ターゲット検出イベント
    sceneEl.addEventListener('targetFound', onTargetFound);
    sceneEl.addEventListener('targetLost', onTargetLost);

    return () => {
      sceneEl.removeEventListener('targetFound', onTargetFound);
      sceneEl.removeEventListener('targetLost', onTargetLost);
    };
  }, [onTargetFound, onTargetLost]);

  return (
    <div ref={sceneRef} className="fixed inset-0">
      <a-scene
        mindar-image={`imageTargetSrc: ${targetUrl}; maxTrack: 1`}
        color-space="sRGB"
        renderer="colorManagement: true, physicallyCorrectLights"
        vr-mode-ui="enabled: false"
        device-orientation-permission-ui="enabled: false"
      >
        <a-camera position="0 0 0" look-controls="enabled: false" />

        <a-entity mindar-image-target="targetIndex: 0">
          <a-plane
            src={signboard.src}
            position={`${transform.position[0]} ${transform.position[1]} ${transform.position[2]}`}
            rotation={`${transform.rotation[0]} ${transform.rotation[1]} ${transform.rotation[2]}`}
            scale={`${transform.scale[0]} ${transform.scale[1]} ${transform.scale[2]}`}
            width={1}
            height={1}
            material="transparent: true; alphaTest: 0.5"
          />
        </a-entity>
      </a-scene>
    </div>
  );
};
```

---

### 3.3 タッチジェスチャーハンドリング

#### 3.3.1 useGesture フック（`src/hooks/useGesture.ts`）

```typescript
import { useCallback, useRef, useState } from 'react';

import type { Transform } from '../types/ar';

interface GestureState {
  isDragging: boolean;
  isPinching: boolean;
  isRotating: boolean;
}

export const useGesture = (
  initialTransform: Transform,
  onTransformChange: (transform: Transform) => void
) => {
  const [transform, setTransform] = useState<Transform>(initialTransform);
  const [gestureState, setGestureState] = useState<GestureState>({
    isDragging: false,
    isPinching: false,
    isRotating: false,
  });

  const lastTouchRef = useRef<{ x: number; y: number } | null>(null);
  const initialDistanceRef = useRef<number>(0);
  const initialScaleRef = useRef<number>(1);

  // ドラッグ処理
  const handleDragStart = useCallback((e: TouchEvent) => {
    if (e.touches.length === 1) {
      lastTouchRef.current = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
      };
      setGestureState((prev) => ({ ...prev, isDragging: true }));
    }
  }, []);

  const handleDragMove = useCallback(
    (e: TouchEvent) => {
      if (!gestureState.isDragging || !lastTouchRef.current) return;

      const deltaX = e.touches[0].clientX - lastTouchRef.current.x;
      const deltaY = e.touches[0].clientY - lastTouchRef.current.y;

      const newPosition: [number, number, number] = [
        transform.position[0] + deltaX * 0.001,
        transform.position[1] - deltaY * 0.001,
        transform.position[2],
      ];

      const newTransform = { ...transform, position: newPosition };
      setTransform(newTransform);
      onTransformChange(newTransform);

      lastTouchRef.current = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
      };
    },
    [gestureState.isDragging, transform, onTransformChange]
  );

  const handleDragEnd = useCallback(() => {
    setGestureState((prev) => ({ ...prev, isDragging: false }));
    lastTouchRef.current = null;
  }, []);

  // ピンチ処理
  const handlePinchStart = useCallback((e: TouchEvent) => {
    if (e.touches.length === 2) {
      const distance = Math.hypot(
        e.touches[1].clientX - e.touches[0].clientX,
        e.touches[1].clientY - e.touches[0].clientY
      );
      initialDistanceRef.current = distance;
      initialScaleRef.current = transform.scale[0];
      setGestureState((prev) => ({ ...prev, isPinching: true }));
    }
  }, [transform.scale]);

  const handlePinchMove = useCallback(
    (e: TouchEvent) => {
      if (!gestureState.isPinching || e.touches.length !== 2) return;

      const distance = Math.hypot(
        e.touches[1].clientX - e.touches[0].clientX,
        e.touches[1].clientY - e.touches[0].clientY
      );

      const scale = (distance / initialDistanceRef.current) * initialScaleRef.current;
      const clampedScale = Math.max(0.5, Math.min(3, scale)); // 0.5x ~ 3x

      const newScale: [number, number, number] = [clampedScale, clampedScale, clampedScale];
      const newTransform = { ...transform, scale: newScale };
      setTransform(newTransform);
      onTransformChange(newTransform);
    },
    [gestureState.isPinching, transform, onTransformChange]
  );

  const handlePinchEnd = useCallback(() => {
    setGestureState((prev) => ({ ...prev, isPinching: false }));
  }, []);

  return {
    transform,
    gestureState,
    handlers: {
      handleDragStart,
      handleDragMove,
      handleDragEnd,
      handlePinchStart,
      handlePinchMove,
      handlePinchEnd,
    },
  };
};
```

---

### 3.4 デザイン切替UI

#### 3.4.1 SignboardSwitcher コンポーネント（`src/components/ui/SignboardSwitcher.tsx`）

```typescript
import type { SignboardDesign } from '../../types/signboard';

interface SignboardSwitcherProps {
  designs: SignboardDesign[];
  currentDesignId: string;
  onDesignChange: (designId: string) => void;
  isVisible: boolean;
  onClose: () => void;
}

export const SignboardSwitcher = ({
  designs,
  currentDesignId,
  onDesignChange,
  isVisible,
  onClose,
}: SignboardSwitcherProps) => {
  if (!isVisible) return null;

  return (
    <div className="fixed inset-0 z-40 flex items-end bg-black bg-opacity-50">
      <div className="w-full rounded-t-2xl bg-white p-6">
        <div className="mb-4 flex items-center justify-between">
          <h3 className="text-lg font-bold">デザインを選択</h3>
          <button
            onClick={onClose}
            className="rounded-full p-2 hover:bg-gray-100"
          >
            ✕
          </button>
        </div>

        <div className="grid grid-cols-3 gap-4">
          {designs.map((design) => (
            <button
              key={design.id}
              onClick={() => {
                onDesignChange(design.id);
                onClose();
              }}
              className={`relative overflow-hidden rounded-lg border-2 transition-all ${
                currentDesignId === design.id
                  ? 'border-blue-500 ring-2 ring-blue-200'
                  : 'border-gray-300 hover:border-gray-400'
              }`}
            >
              <img
                src={design.thumbnail || design.src}
                alt={design.name}
                className="aspect-square w-full object-cover"
              />
              {currentDesignId === design.id && (
                <div className="absolute right-2 top-2 rounded-full bg-blue-500 p-1 text-white">
                  ✓
                </div>
              )}
              <div className="p-2 text-center text-sm font-medium">
                {design.name}
              </div>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
};
```

#### 3.4.2 ControlsOverlay コンポーネント（`src/components/ui/ControlsOverlay.tsx`）

```typescript
interface ControlsOverlayProps {
  isTracking: boolean;
  showHelp: boolean;
  onToggleDesignSwitcher: () => void;
  onDismissHelp: () => void;
}

export const ControlsOverlay = ({
  isTracking,
  showHelp,
  onToggleDesignSwitcher,
  onDismissHelp,
}: ControlsOverlayProps) => {
  return (
    <>
      {/* 操作説明 */}
      {showHelp && (
        <div className="fixed left-1/2 top-4 z-30 -translate-x-1/2 transform rounded-lg bg-black bg-opacity-75 px-4 py-3 text-white shadow-lg">
          <button
            onClick={onDismissHelp}
            className="absolute right-2 top-2 text-white opacity-75 hover:opacity-100"
          >
            ✕
          </button>
          <div className="space-y-2 text-sm">
            <p>📱 1本指ドラッグ: 移動</p>
            <p>🤏 ピンチ: 拡大縮小</p>
            <p>�� 2本指回転: 回転</p>
          </div>
        </div>
      )}

      {/* トラッキング状態表示 */}
      {!isTracking && (
        <div className="fixed left-1/2 top-1/2 z-20 -translate-x-1/2 -translate-y-1/2 transform rounded-lg bg-black bg-opacity-75 px-6 py-4 text-center text-white">
          <p className="text-lg font-medium">📷 ターゲット画像を探しています...</p>
          <p className="mt-2 text-sm opacity-75">
            カメラをターゲット画像に向けてください
          </p>
        </div>
      )}

      {/* デザイン切替ボタン */}
      {isTracking && (
        <button
          onClick={onToggleDesignSwitcher}
          className="fixed bottom-6 right-6 z-30 rounded-full bg-blue-500 p-4 text-white shadow-lg hover:bg-blue-600"
        >
          🎨
        </button>
      )}
    </>
  );
};
```

---

### 3.5 看板デザインデータ

#### 3.5.1 サンプルデザイン（`src/data/signboards.ts`）

```typescript
import type { SignboardDesign } from '../types/signboard';

export const SIGNBOARD_DESIGNS: SignboardDesign[] = [
  {
    id: 'signboard-1',
    name: 'シンプル',
    type: 'image',
    src: '/images/signboard-1.png',
    defaultScale: [1, 1, 1],
    thumbnail: '/images/signboard-1-thumb.png',
  },
  {
    id: 'signboard-2',
    name: 'カラフル',
    type: 'image',
    src: '/images/signboard-2.png',
    defaultScale: [1.2, 1.2, 1.2],
    thumbnail: '/images/signboard-2-thumb.png',
  },
  {
    id: 'signboard-3',
    name: 'エレガント',
    type: 'image',
    src: '/images/signboard-3.png',
    defaultScale: [1, 1, 1],
    thumbnail: '/images/signboard-3-thumb.png',
  },
];
```

---

### 3.6 App.tsx の更新

```typescript
import { useState } from 'react';

import { ARScene } from './components/ar/ARScene';
import { ControlsOverlay } from './components/ui/ControlsOverlay';
import { ErrorDialog } from './components/ui/ErrorDialog';
import { LoadingScreen } from './components/ui/LoadingScreen';
import { SignboardSwitcher } from './components/ui/SignboardSwitcher';
import { MINDAR_CONFIG, DEFAULT_TRANSFORM } from './constants/ar';
import { SIGNBOARD_DESIGNS } from './data/signboards';
import { useARInitialize } from './hooks/useARInitialize';
import { useCamera } from './hooks/useCamera';
import { useGesture } from './hooks/useGesture';

function App() {
  const { isInitializing, isInitialized, error: arError, initialize } = useARInitialize();
  const { permission, error: cameraError, requestCameraPermission } = useCamera();

  const [isTracking, setIsTracking] = useState(false);
  const [showHelp, setShowHelp] = useState(true);
  const [showDesignSwitcher, setShowDesignSwitcher] = useState(false);
  const [currentDesignId, setCurrentDesignId] = useState(SIGNBOARD_DESIGNS[0].id);

  const currentDesign = SIGNBOARD_DESIGNS.find((d) => d.id === currentDesignId) || SIGNBOARD_DESIGNS[0];

  const { transform, handlers } = useGesture(DEFAULT_TRANSFORM, (newTransform) => {
    console.log('Transform updated:', newTransform);
  });

  const handleStart = async () => {
    await requestCameraPermission();
    if (permission === 'granted') {
      await initialize();
    }
  };

  const currentError = arError || cameraError;

  return (
    <div className="h-screen w-screen">
      {isInitializing && <LoadingScreen />}

      {currentError && <ErrorDialog error={currentError} onRetry={handleStart} />}

      {!isInitialized && !isInitializing && (
        <div className="flex h-full items-center justify-center bg-gray-900">
          <button
            onClick={handleStart}
            className="rounded-lg bg-blue-500 px-8 py-4 text-xl font-bold text-white hover:bg-blue-600"
          >
            AR体験を開始
          </button>
        </div>
      )}

      {isInitialized && (
        <>
          <ARScene
            targetUrl={MINDAR_CONFIG.targetUrl}
            signboard={currentDesign}
            transform={transform}
            onTargetFound={() => setIsTracking(true)}
            onTargetLost={() => setIsTracking(false)}
            onTransformChange={(newTransform) => console.log(newTransform)}
          />

          <ControlsOverlay
            isTracking={isTracking}
            showHelp={showHelp}
            onToggleDesignSwitcher={() => setShowDesignSwitcher(!showDesignSwitcher)}
            onDismissHelp={() => setShowHelp(false)}
          />

          <SignboardSwitcher
            designs={SIGNBOARD_DESIGNS}
            currentDesignId={currentDesignId}
            onDesignChange={setCurrentDesignId}
            isVisible={showDesignSwitcher}
            onClose={() => setShowDesignSwitcher(false)}
          />
        </>
      )}
    </div>
  );
}

export default App;
```

---

## 4. 実装順序と工数見積もり

### 4.1 推奨実装順序

1. **ターゲット画像の準備** (30分)
2. **ARSceneコンポーネント** (2時間)
3. **トラッキング状態管理** (1時間)
4. **useGestureフック（ドラッグ）** (2時間)
5. **useGestureフック（ピンチ）** (1.5時間)
6. **useGestureフック（回転）** (1.5時間)
7. **SignboardSwitcherコンポーネント** (1.5時間)
8. **ControlsOverlayコンポーネント** (1時間)
9. **サンプルデザインデータ** (30分)
10. **App.tsx統合** (1.5時間)
11. **動作確認・デバッグ** (3時間)

**合計工数**: 約16時間（2日相当）

---

## 5. テスト計画

### 5.1 機能テスト

#### ARシーン表示
- [ ] A-Frameシーンが正しく初期化される
- [ ] カメラストリームが表示される
- [ ] ターゲット画像を認識する
- [ ] 看板画像がターゲット上に表示される

#### トラッキング
- [ ] ターゲット検出時にisTrackingがtrueになる
- [ ] ターゲットロスト時にisTrackingがfalseになる
- [ ] トラッキング状態に応じたUI表示

#### ジェスチャー操作
- [ ] 1本指ドラッグで看板が移動する
- [ ] ピンチで看板が拡大縮小する
- [ ] 2本指回転で看板が回転する
- [ ] スケールが0.5x〜3xの範囲に制限される

#### デザイン切替
- [ ] デザイン切替ボタンが表示される
- [ ] デザイン選択UIが開く
- [ ] デザイン変更が即座に反映される
- [ ] サムネイル画像が正しく表示される

### 5.2 実機テスト

#### iOS Safari
- [ ] AR表示が正常に動作する
- [ ] タッチジェスチャーが正確に認識される
- [ ] フレームレートが30fps以上

#### Android Chrome
- [ ] AR表示が正常に動作する
- [ ] タッチジェスチャーが正確に認識される
- [ ] フレームレートが30fps以上

---

## 6. リスクと対策

### 6.1 技術的リスク

| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| A-FrameとReactの統合が複雑 | 高 | 中 | refを使用した直接DOM操作 |
| ターゲット認識率が低い | 高 | 中 | 高品質なターゲット画像を準備 |
| ジェスチャー認識の精度不足 | 中 | 中 | デバウンス処理とスムージング |
| パフォーマンス低下 | 高 | 中 | Three.jsオブジェクト数の制限 |

---

## 7. 参考資料

### 7.1 公式ドキュメント

- [MindAR Image Tracking](https://hiukim.github.io/mind-ar-js-doc/quick-start/tracking)
- [A-Frame Components](https://aframe.io/docs/1.5.0/introduction/)
- [Three.js Raycaster](https://threejs.org/docs/#api/en/core/Raycaster)

### 7.2 サンプル画像リソース

- [Unsplash](https://unsplash.com/) - 高品質な無料画像
- [Pexels](https://www.pexels.com/) - 商用利用可能な画像

---

**以上がフェーズ3の詳細設計書です。実装を開始してよろしいでしょうか？**
