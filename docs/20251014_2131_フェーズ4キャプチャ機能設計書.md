# フェーズ4：キャプチャ機能 設計書

**作成日**: 2025年10月14日
**フェーズ**: 4 / 5
**目的**: AR表示のキャプチャと画像保存機能の実装

---

## 1. 概要

### 1.1 目的

フェーズ3で実装したAR表示とインタラクション機能に、キャプチャ機能を追加します。カメラ映像とAR表示を合成した画像をキャプチャし、端末に保存できるようにします。

### 1.2 主な機能

- AR表示のスクリーンショット撮影
- カメラ映像とAR表示の合成
- 画像の端末への保存
- キャプチャプレビュー表示
- SNS共有機能（オプション）

---

## 2. 機能要件

### 2.1 キャプチャ機能

#### 2.1.1 キャプチャボタン

**要件**:
- トラッキング中のみ表示
- タップでキャプチャ実行
- シャッター音（オプション）
- キャプチャ中のローディング表示

**UI配置**:
- 画面下部中央
- 他のUIと干渉しない位置
- 大きめのボタン（親指で押しやすい）

#### 2.1.2 キャプチャ処理

**技術仕様**:
```typescript
interface CaptureOptions {
  width?: number;          // 出力画像の幅（デフォルト: 画面幅）
  height?: number;         // 出力画像の高さ（デフォルト: 画面高さ）
  quality?: number;        // JPEG品質 0.0-1.0（デフォルト: 0.92）
  format?: 'image/jpeg' | 'image/png';  // 画像フォーマット
}

interface CaptureResult {
  dataUrl: string;         // Base64エンコードされた画像データ
  blob: Blob;              // Blob形式の画像データ
  width: number;           // 実際の画像幅
  height: number;          // 実際の画像高さ
  timestamp: number;       // キャプチャ時刻（Unix timestamp）
}
```

**処理フロー**:
1. A-Frameシーンのcanvasを取得
2. canvasからBase64画像データを取得
3. データをBlobに変換
4. CaptureResult形式でデータを返す

### 2.2 画像保存機能

#### 2.2.1 保存方法

**ブラウザAPI使用**:
```typescript
// HTML5 Download API
const link = document.createElement('a');
link.download = `ar-signboard-${timestamp}.jpg`;
link.href = dataUrl;
link.click();
```

**ファイル名形式**:
- `ar-signboard-YYYYMMDD-HHMMSS.jpg`
- 例: `ar-signboard-20251014-213045.jpg`

#### 2.2.2 保存先

- **iOS Safari**: ダウンロードフォルダまたは写真アプリ（長押しで選択）
- **Android Chrome**: ダウンロードフォルダ

### 2.3 プレビュー機能

#### 2.3.1 プレビューモーダル

**表示内容**:
- キャプチャした画像
- 保存ボタン
- 再撮影ボタン
- 共有ボタン（オプション）
- 閉じるボタン

**動作**:
- キャプチャ直後に自動表示
- モーダルオーバーレイで全画面表示
- 背景タップで閉じる

### 2.4 共有機能（オプション）

#### 2.4.1 Web Share API

```typescript
if (navigator.share && navigator.canShare) {
  await navigator.share({
    files: [new File([blob], 'ar-signboard.jpg', { type: 'image/jpeg' })],
    title: 'AR看板',
    text: 'AR看板アプリでキャプチャしました'
  });
}
```

**対応OS**:
- iOS Safari: 完全対応
- Android Chrome: 完全対応
- デスクトップ: 限定的対応

---

## 3. 技術設計

### 3.1 ディレクトリ構成

```
src/
├── ar/
│   └── captureService.ts          # キャプチャサービス（新規）
├── components/
│   ├── ar/
│   │   └── ARScene.tsx             # キャプチャメソッド追加
│   └── ui/
│       ├── CaptureButton.tsx       # キャプチャボタン（新規）
│       └── CapturePreview.tsx      # プレビューモーダル（新規）
├── hooks/
│   └── useCapture.ts               # キャプチャフック（新規）
└── utils/
    └── imageUtils.ts               # 画像処理ユーティリティ（新規）
```

### 3.2 コンポーネント設計

#### 3.2.1 CaptureButton

**役割**: キャプチャ実行ボタン

**Props**:
```typescript
interface CaptureButtonProps {
  onCapture: () => void;
  isCapturing: boolean;
  disabled?: boolean;
}
```

**実装**:
```tsx
export const CaptureButton = ({
  onCapture,
  isCapturing,
  disabled
}: CaptureButtonProps) => {
  return (
    <button
      onClick={onCapture}
      disabled={disabled || isCapturing}
      className="fixed bottom-20 left-1/2 z-30 -translate-x-1/2
                 rounded-full bg-white p-4 shadow-lg"
      aria-label="写真を撮る"
    >
      {isCapturing ? (
        <div className="animate-spin">⏳</div>
      ) : (
        <div className="text-3xl">📷</div>
      )}
    </button>
  );
};
```

#### 3.2.2 CapturePreview

**役割**: キャプチャ画像のプレビューと保存

**Props**:
```typescript
interface CapturePreviewProps {
  imageUrl: string | null;
  onSave: () => void;
  onRetake: () => void;
  onShare?: () => void;
  onClose: () => void;
}
```

**実装**:
```tsx
export const CapturePreview = ({
  imageUrl,
  onSave,
  onRetake,
  onShare,
  onClose
}: CapturePreviewProps) => {
  if (!imageUrl) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black bg-opacity-90">
      <div className="flex h-full flex-col items-center justify-center p-4">
        {/* 画像表示 */}
        <img
          src={imageUrl}
          alt="キャプチャプレビュー"
          className="max-h-[70vh] rounded-lg shadow-xl"
        />

        {/* ボタン群 */}
        <div className="mt-6 flex gap-4">
          <button onClick={onRetake} className="btn-secondary">
            再撮影
          </button>
          <button onClick={onSave} className="btn-primary">
            保存
          </button>
          {onShare && (
            <button onClick={onShare} className="btn-secondary">
              共有
            </button>
          )}
        </div>

        {/* 閉じるボタン */}
        <button
          onClick={onClose}
          className="absolute right-4 top-4 text-white"
        >
          ✕
        </button>
      </div>
    </div>
  );
};
```

### 3.3 フック設計

#### 3.3.1 useCapture

**役割**: キャプチャ機能の状態管理とロジック

**実装**:
```typescript
import { useState, useCallback } from 'react';
import { captureARScene, saveImage, shareImage } from '../ar/captureService';

export const useCapture = () => {
  const [isCapturing, setIsCapturing] = useState(false);
  const [captureResult, setCaptureResult] = useState<CaptureResult | null>(null);
  const [error, setError] = useState<Error | null>(null);

  const capture = useCallback(async (sceneElement: HTMLElement) => {
    setIsCapturing(true);
    setError(null);

    try {
      const result = await captureARScene(sceneElement);
      setCaptureResult(result);
      return result;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setIsCapturing(false);
    }
  }, []);

  const save = useCallback(async () => {
    if (!captureResult) return;

    try {
      await saveImage(captureResult);
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [captureResult]);

  const share = useCallback(async () => {
    if (!captureResult) return;

    try {
      await shareImage(captureResult);
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [captureResult]);

  const reset = useCallback(() => {
    setCaptureResult(null);
    setError(null);
  }, []);

  return {
    isCapturing,
    captureResult,
    error,
    capture,
    save,
    share,
    reset
  };
};
```

### 3.4 サービス設計

#### 3.4.1 captureService.ts

**役割**: キャプチャ処理の実装

```typescript
import type { CaptureOptions, CaptureResult } from '../types/capture';

/**
 * A-FrameシーンをキャプチャしてBase64画像データを取得
 */
export const captureARScene = async (
  sceneElement: HTMLElement,
  options: CaptureOptions = {}
): Promise<CaptureResult> => {
  const scene = sceneElement.querySelector('a-scene') as any;
  if (!scene) {
    throw new Error('A-Frame scene not found');
  }

  // A-Frameのcanvasを取得
  const canvas = scene.components.screenshot?.getCanvas();
  if (!canvas) {
    throw new Error('Canvas not found');
  }

  // オプションのデフォルト値
  const {
    width = canvas.width,
    height = canvas.height,
    quality = 0.92,
    format = 'image/jpeg'
  } = options;

  // canvasからBase64データを取得
  const dataUrl = canvas.toDataURL(format, quality);

  // BlobURLに変換
  const blob = await (await fetch(dataUrl)).blob();

  return {
    dataUrl,
    blob,
    width,
    height,
    timestamp: Date.now()
  };
};

/**
 * 画像を端末に保存
 */
export const saveImage = async (result: CaptureResult): Promise<void> => {
  const timestamp = new Date(result.timestamp).toISOString()
    .replace(/:/g, '')
    .replace(/\..+/, '')
    .replace('T', '-');

  const filename = `ar-signboard-${timestamp}.jpg`;

  // HTML5 Download APIを使用
  const link = document.createElement('a');
  link.href = result.dataUrl;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

/**
 * Web Share APIで画像を共有
 */
export const shareImage = async (result: CaptureResult): Promise<void> => {
  if (!navigator.share || !navigator.canShare) {
    throw new Error('Web Share API not supported');
  }

  const file = new File(
    [result.blob],
    'ar-signboard.jpg',
    { type: 'image/jpeg' }
  );

  const shareData = {
    files: [file],
    title: 'AR看板',
    text: 'AR看板アプリでキャプチャしました'
  };

  if (!navigator.canShare(shareData)) {
    throw new Error('Cannot share this data');
  }

  await navigator.share(shareData);
};
```

### 3.5 型定義

#### 3.5.1 src/types/capture.ts

```typescript
/**
 * キャプチャ関連の型定義
 */

export interface CaptureOptions {
  width?: number;
  height?: number;
  quality?: number;
  format?: 'image/jpeg' | 'image/png';
}

export interface CaptureResult {
  dataUrl: string;
  blob: Blob;
  width: number;
  height: number;
  timestamp: number;
}

export interface CaptureError {
  type: CaptureErrorType;
  message: string;
  originalError?: Error;
}

export const CaptureErrorType = {
  SCENE_NOT_FOUND: 'SCENE_NOT_FOUND',
  CANVAS_NOT_FOUND: 'CANVAS_NOT_FOUND',
  CAPTURE_FAILED: 'CAPTURE_FAILED',
  SAVE_FAILED: 'SAVE_FAILED',
  SHARE_NOT_SUPPORTED: 'SHARE_NOT_SUPPORTED',
  SHARE_FAILED: 'SHARE_FAILED',
} as const;

export type CaptureErrorType = typeof CaptureErrorType[keyof typeof CaptureErrorType];
```

---

## 4. App.tsx統合

### 4.1 更新内容

```tsx
import { useState } from 'react';

import { ARScene } from './components/ar/ARScene';
import { CaptureButton } from './components/ui/CaptureButton';
import { CapturePreview } from './components/ui/CapturePreview';
import { ControlsOverlay } from './components/ui/ControlsOverlay';
// ... その他のimport

function App() {
  // ... 既存のstate

  const [showCapturePreview, setShowCapturePreview] = useState(false);
  const { isCapturing, captureResult, capture, save, share, reset } = useCapture();

  const handleCapture = async () => {
    const sceneElement = document.querySelector('.ar-scene-container');
    if (sceneElement) {
      await capture(sceneElement as HTMLElement);
      setShowCapturePreview(true);
    }
  };

  const handleSave = async () => {
    await save();
    setShowCapturePreview(false);
    reset();
  };

  const handleRetake = () => {
    setShowCapturePreview(false);
    reset();
  };

  return (
    <div className="h-screen w-screen">
      {/* ... 既存のコード */}

      {isInitialized && (
        <>
          <div className="ar-scene-container">
            <ARScene
              targetUrl={MINDAR_CONFIG.targetUrl}
              signboard={currentDesign}
              transform={transform}
              onTargetFound={() => setIsTracking(true)}
              onTargetLost={() => setIsTracking(false)}
            />
          </div>

          <ControlsOverlay
            isTracking={isTracking}
            showHelp={showHelp}
            onToggleDesignSwitcher={() => setShowDesignSwitcher(!showDesignSwitcher)}
            onDismissHelp={() => setShowHelp(false)}
          />

          {/* キャプチャボタン */}
          {isTracking && (
            <CaptureButton
              onCapture={handleCapture}
              isCapturing={isCapturing}
            />
          )}

          {/* キャプチャプレビュー */}
          <CapturePreview
            imageUrl={captureResult?.dataUrl || null}
            onSave={handleSave}
            onRetake={handleRetake}
            onShare={navigator.share ? share : undefined}
            onClose={handleRetake}
          />

          <SignboardSwitcher
            designs={SIGNBOARD_DESIGNS}
            currentDesignId={currentDesignId}
            onDesignChange={setCurrentDesignId}
            isVisible={showDesignSwitcher}
            onClose={() => setShowDesignSwitcher(false)}
          />
        </>
      )}
    </div>
  );
}
```

---

## 5. パフォーマンス最適化

### 5.1 画像サイズ最適化

**推奨設定**:
- 幅: 1280px以下
- JPEG品質: 0.85-0.92
- ファイルサイズ: 500KB-2MB目標

### 5.2 メモリ管理

**注意点**:
- キャプチャ後は不要なデータURLをクリーンアップ
- Blobの参照をリセット
- 連続キャプチャ時のメモリリーク防止

```typescript
useEffect(() => {
  return () => {
    if (captureResult?.dataUrl) {
      URL.revokeObjectURL(captureResult.dataUrl);
    }
  };
}, [captureResult]);
```

---

## 6. エラーハンドリング

### 6.1 エラーケース

| エラー | 原因 | 対応 |
|--------|------|------|
| シーンが見つからない | A-Frameの初期化未完了 | ローディング表示、リトライ |
| canvasが見つからない | レンダリング未完了 | 少し待ってからリトライ |
| 保存失敗 | ブラウザ権限、ストレージ不足 | エラーメッセージ表示 |
| 共有失敗 | Web Share API非対応 | 共有ボタン非表示、代替手段提示 |

### 6.2 エラー表示

```tsx
{error && (
  <div className="fixed bottom-4 left-4 right-4 rounded-lg bg-red-500 p-4 text-white">
    <p className="font-bold">エラーが発生しました</p>
    <p className="text-sm">{error.message}</p>
  </div>
)}
```

---

## 7. テスト項目

### 7.1 機能テスト

- [ ] キャプチャボタンが正しく表示される
- [ ] トラッキング中のみキャプチャボタンが有効
- [ ] キャプチャ実行でプレビューが表示される
- [ ] プレビュー画像が正しく表示される
- [ ] 保存ボタンで画像がダウンロードされる
- [ ] 再撮影でプレビューが閉じる
- [ ] 共有ボタンで共有シートが開く（iOS/Android）

### 7.2 端末テスト

- [ ] iOS Safari: キャプチャ・保存・共有
- [ ] Android Chrome: キャプチャ・保存・共有
- [ ] 低性能端末でのパフォーマンス
- [ ] 異なる画面サイズでの表示

### 7.3 エラーハンドリングテスト

- [ ] シーン初期化前のキャプチャ試行
- [ ] ストレージ不足時の保存
- [ ] Web Share API非対応端末での共有

---

## 8. 実装順序

### 8.1 ステップ1: 基本キャプチャ機能

1. 型定義の作成 (`src/types/capture.ts`)
2. キャプチャサービスの実装 (`src/ar/captureService.ts`)
3. useCaptureフックの実装 (`src/hooks/useCapture.ts`)

### 8.2 ステップ2: UIコンポーネント

1. CaptureButtonの実装
2. CapturePreviewの実装
3. App.tsxへの統合

### 8.3 ステップ3: 共有機能（オプション）

1. Web Share APIの実装
2. 共有ボタンの追加
3. フォールバック処理

### 8.4 ステップ4: テストと最適化

1. 実機テスト
2. パフォーマンス測定
3. エラーハンドリングの改善

---

## 9. 完成の定義

### 9.1 必須要件

- ✅ キャプチャボタンが機能する
- ✅ プレビュー表示が正しく動作する
- ✅ 画像保存が正常に完了する
- ✅ iOS/Androidの両方で動作確認

### 9.2 オプション要件

- ⭕ Web Share APIによる共有機能
- ⭕ シャッター音の実装
- ⭕ 連続キャプチャ機能
- ⭕ ギャラリー表示

---

## 10. 次のフェーズへ

フェーズ4完了後、フェーズ5（最終調整とデプロイ）に進みます。

**フェーズ5の内容**:
- パフォーマンス最適化
- エラーハンドリングの強化
- アクセシビリティ改善
- PWA対応
- デプロイ準備
